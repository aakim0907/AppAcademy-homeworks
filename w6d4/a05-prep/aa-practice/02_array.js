// primes(num) returns an array of the first "num" primes.
// You may wish to use an is_prime? helper method.


// Write an Array#dups method that will return a hash containing the indices of all
// duplicate elements. The keys are the duplicate elements; the values are
// arrays of their indices in ascending order, e.g.
// [1, 3, 4, 3, 0, 3, 0].dups => { 3 => [1, 3, 5], 0 => [4, 6] }


// Write a version of merge. This should NOT modify the original hash


// Takes a multi-dimentional array and returns a single array of all the elements
// [1,[2,3], [4,[5]]].my_controlled_flatten(1) => [1,2,3,4,5]



// Write a version of flatten that only flattens n levels of an array.
// E.g. If you have an array with 3 levels of nested arrays, and run
// my_flatten(1), you should return an array with 2 levels of nested
// arrays
//
// [1,[2,3], [4,[5]]].my_controlled_flatten(1) => [1,2,3,4,[5]]



// Write a method that returns the median of elements in an array
// If the length is even, return the average of the middle two elements



// Write a monkey patch of binary search:
// E.g. [1, 2, 3, 4, 5, 7].my_bsearch(5) => 4



// Write a method, `Array#two_sum`, that finds all pairs of positions where the
// elements at those positions sum to zero.
//
// NB: ordering matters. I want each of the pairs to be sorted smaller index
// before bigger index. I want the array of pairs to be sorted
// "dictionary-wise":
//   [0, 2] before [1, 2] (smaller first elements come first)
//   [0, 1] before [0, 2] (then smaller second elements come first)




// Write a method that returns the factors of a number in ascending order.
